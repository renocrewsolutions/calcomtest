/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import * as common from "@nestjs/common";
import * as swagger from "@nestjs/swagger";
import { isRecordNotFoundError } from "../../prisma.util";
import * as errors from "../../errors";
import { Request } from "express";
import { plainToClass } from "class-transformer";
import { ApiNestedQuery } from "../../decorators/api-nested-query.decorator";
import { UserService } from "../user.service";
import { UserCreateInput } from "./UserCreateInput";
import { User } from "./User";
import { UserFindManyArgs } from "./UserFindManyArgs";
import { UserWhereUniqueInput } from "./UserWhereUniqueInput";
import { UserUpdateInput } from "./UserUpdateInput";
import { AccessCodeFindManyArgs } from "../../accessCode/base/AccessCodeFindManyArgs";
import { AccessCode } from "../../accessCode/base/AccessCode";
import { AccessCodeWhereUniqueInput } from "../../accessCode/base/AccessCodeWhereUniqueInput";
import { AccountFindManyArgs } from "../../account/base/AccountFindManyArgs";
import { Account } from "../../account/base/Account";
import { AccountWhereUniqueInput } from "../../account/base/AccountWhereUniqueInput";
import { ApiKeyFindManyArgs } from "../../apiKey/base/ApiKeyFindManyArgs";
import { ApiKey } from "../../apiKey/base/ApiKey";
import { ApiKeyWhereUniqueInput } from "../../apiKey/base/ApiKeyWhereUniqueInput";
import { AvailabilityFindManyArgs } from "../../availability/base/AvailabilityFindManyArgs";
import { Availability } from "../../availability/base/Availability";
import { AvailabilityWhereUniqueInput } from "../../availability/base/AvailabilityWhereUniqueInput";
import { OutOfOfficeEntryFindManyArgs } from "../../outOfOfficeEntry/base/OutOfOfficeEntryFindManyArgs";
import { OutOfOfficeEntry } from "../../outOfOfficeEntry/base/OutOfOfficeEntry";
import { OutOfOfficeEntryWhereUniqueInput } from "../../outOfOfficeEntry/base/OutOfOfficeEntryWhereUniqueInput";
import { BookingFindManyArgs } from "../../booking/base/BookingFindManyArgs";
import { Booking } from "../../booking/base/Booking";
import { BookingWhereUniqueInput } from "../../booking/base/BookingWhereUniqueInput";
import { CredentialFindManyArgs } from "../../credential/base/CredentialFindManyArgs";
import { Credential } from "../../credential/base/Credential";
import { CredentialWhereUniqueInput } from "../../credential/base/CredentialWhereUniqueInput";
import { FeedbackFindManyArgs } from "../../feedback/base/FeedbackFindManyArgs";
import { Feedback } from "../../feedback/base/Feedback";
import { FeedbackWhereUniqueInput } from "../../feedback/base/FeedbackWhereUniqueInput";
import { HostFindManyArgs } from "../../host/base/HostFindManyArgs";
import { Host } from "../../host/base/Host";
import { HostWhereUniqueInput } from "../../host/base/HostWhereUniqueInput";
import { ImpersonationFindManyArgs } from "../../impersonation/base/ImpersonationFindManyArgs";
import { Impersonation } from "../../impersonation/base/Impersonation";
import { ImpersonationWhereUniqueInput } from "../../impersonation/base/ImpersonationWhereUniqueInput";
import { EventTypeFindManyArgs } from "../../eventType/base/EventTypeFindManyArgs";
import { EventType } from "../../eventType/base/EventType";
import { EventTypeWhereUniqueInput } from "../../eventType/base/EventTypeWhereUniqueInput";
import { ProfileFindManyArgs } from "../../profile/base/ProfileFindManyArgs";
import { Profile } from "../../profile/base/Profile";
import { ProfileWhereUniqueInput } from "../../profile/base/ProfileWhereUniqueInput";
import { AppRoutingFormsFormFindManyArgs } from "../../appRoutingFormsForm/base/AppRoutingFormsFormFindManyArgs";
import { AppRoutingFormsForm } from "../../appRoutingFormsForm/base/AppRoutingFormsForm";
import { AppRoutingFormsFormWhereUniqueInput } from "../../appRoutingFormsForm/base/AppRoutingFormsFormWhereUniqueInput";
import { ScheduleFindManyArgs } from "../../schedule/base/ScheduleFindManyArgs";
import { Schedule } from "../../schedule/base/Schedule";
import { ScheduleWhereUniqueInput } from "../../schedule/base/ScheduleWhereUniqueInput";
import { SelectedCalendarFindManyArgs } from "../../selectedCalendar/base/SelectedCalendarFindManyArgs";
import { SelectedCalendar } from "../../selectedCalendar/base/SelectedCalendar";
import { SelectedCalendarWhereUniqueInput } from "../../selectedCalendar/base/SelectedCalendarWhereUniqueInput";
import { SessionFindManyArgs } from "../../session/base/SessionFindManyArgs";
import { Session } from "../../session/base/Session";
import { SessionWhereUniqueInput } from "../../session/base/SessionWhereUniqueInput";
import { MembershipFindManyArgs } from "../../membership/base/MembershipFindManyArgs";
import { Membership } from "../../membership/base/Membership";
import { MembershipWhereUniqueInput } from "../../membership/base/MembershipWhereUniqueInput";
import { VerifiedNumberFindManyArgs } from "../../verifiedNumber/base/VerifiedNumberFindManyArgs";
import { VerifiedNumber } from "../../verifiedNumber/base/VerifiedNumber";
import { VerifiedNumberWhereUniqueInput } from "../../verifiedNumber/base/VerifiedNumberWhereUniqueInput";
import { WebhookFindManyArgs } from "../../webhook/base/WebhookFindManyArgs";
import { Webhook } from "../../webhook/base/Webhook";
import { WebhookWhereUniqueInput } from "../../webhook/base/WebhookWhereUniqueInput";
import { WorkflowFindManyArgs } from "../../workflow/base/WorkflowFindManyArgs";
import { Workflow } from "../../workflow/base/Workflow";
import { WorkflowWhereUniqueInput } from "../../workflow/base/WorkflowWhereUniqueInput";

export class UserControllerBase {
  constructor(protected readonly service: UserService) {}
  @common.Post()
  @swagger.ApiCreatedResponse({ type: User })
  async createUser(@common.Body() data: UserCreateInput): Promise<User> {
    return await this.service.createUser({
      data: {
        ...data,

        destinationCalendar: data.destinationCalendar
          ? {
              connect: data.destinationCalendar,
            }
          : undefined,

        movedToProfile: data.movedToProfile
          ? {
              connect: data.movedToProfile,
            }
          : undefined,

        organization: data.organization
          ? {
              connect: data.organization,
            }
          : undefined,

        password: data.password
          ? {
              connect: data.password,
            }
          : undefined,
      },
      select: {
        allowDynamicBooking: true,
        allowSEOIndexing: true,
        appTheme: true,
        avatar: true,
        avatarUrl: true,
        away: true,
        backupCodes: true,
        bio: true,
        brandColor: true,
        bufferTime: true,
        completedOnboarding: true,
        createdDate: true,
        darkBrandColor: true,
        defaultScheduleId: true,

        destinationCalendar: {
          select: {
            id: true,
          },
        },

        disableImpersonation: true,
        email: true,
        emailVerified: true,
        endTime: true,
        hideBranding: true,
        id: true,
        identityProvider: true,
        identityProviderId: true,
        invitedTo: true,
        locale: true,
        locked: true,
        metadata: true,

        movedToProfile: {
          select: {
            id: true,
          },
        },

        name: true,

        organization: {
          select: {
            id: true,
          },
        },

        password: {
          select: {
            id: true,
          },
        },

        receiveMonthlyDigestEmail: true,
        role: true,
        startTime: true,
        theme: true,
        timeFormat: true,
        timeZone: true,
        trialEndsAt: true,
        twoFactorEnabled: true,
        twoFactorSecret: true,
        username: true,
        verified: true,
        weekStart: true,
      },
    });
  }

  @common.Get()
  @swagger.ApiOkResponse({ type: [User] })
  @ApiNestedQuery(UserFindManyArgs)
  async users(@common.Req() request: Request): Promise<User[]> {
    const args = plainToClass(UserFindManyArgs, request.query);
    return this.service.users({
      ...args,
      select: {
        allowDynamicBooking: true,
        allowSEOIndexing: true,
        appTheme: true,
        avatar: true,
        avatarUrl: true,
        away: true,
        backupCodes: true,
        bio: true,
        brandColor: true,
        bufferTime: true,
        completedOnboarding: true,
        createdDate: true,
        darkBrandColor: true,
        defaultScheduleId: true,

        destinationCalendar: {
          select: {
            id: true,
          },
        },

        disableImpersonation: true,
        email: true,
        emailVerified: true,
        endTime: true,
        hideBranding: true,
        id: true,
        identityProvider: true,
        identityProviderId: true,
        invitedTo: true,
        locale: true,
        locked: true,
        metadata: true,

        movedToProfile: {
          select: {
            id: true,
          },
        },

        name: true,

        organization: {
          select: {
            id: true,
          },
        },

        password: {
          select: {
            id: true,
          },
        },

        receiveMonthlyDigestEmail: true,
        role: true,
        startTime: true,
        theme: true,
        timeFormat: true,
        timeZone: true,
        trialEndsAt: true,
        twoFactorEnabled: true,
        twoFactorSecret: true,
        username: true,
        verified: true,
        weekStart: true,
      },
    });
  }

  @common.Get("/:id")
  @swagger.ApiOkResponse({ type: User })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  async user(
    @common.Param() params: UserWhereUniqueInput
  ): Promise<User | null> {
    const result = await this.service.user({
      where: params,
      select: {
        allowDynamicBooking: true,
        allowSEOIndexing: true,
        appTheme: true,
        avatar: true,
        avatarUrl: true,
        away: true,
        backupCodes: true,
        bio: true,
        brandColor: true,
        bufferTime: true,
        completedOnboarding: true,
        createdDate: true,
        darkBrandColor: true,
        defaultScheduleId: true,

        destinationCalendar: {
          select: {
            id: true,
          },
        },

        disableImpersonation: true,
        email: true,
        emailVerified: true,
        endTime: true,
        hideBranding: true,
        id: true,
        identityProvider: true,
        identityProviderId: true,
        invitedTo: true,
        locale: true,
        locked: true,
        metadata: true,

        movedToProfile: {
          select: {
            id: true,
          },
        },

        name: true,

        organization: {
          select: {
            id: true,
          },
        },

        password: {
          select: {
            id: true,
          },
        },

        receiveMonthlyDigestEmail: true,
        role: true,
        startTime: true,
        theme: true,
        timeFormat: true,
        timeZone: true,
        trialEndsAt: true,
        twoFactorEnabled: true,
        twoFactorSecret: true,
        username: true,
        verified: true,
        weekStart: true,
      },
    });
    if (result === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return result;
  }

  @common.Patch("/:id")
  @swagger.ApiOkResponse({ type: User })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  async updateUser(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() data: UserUpdateInput
  ): Promise<User | null> {
    try {
      return await this.service.updateUser({
        where: params,
        data: {
          ...data,

          destinationCalendar: data.destinationCalendar
            ? {
                connect: data.destinationCalendar,
              }
            : undefined,

          movedToProfile: data.movedToProfile
            ? {
                connect: data.movedToProfile,
              }
            : undefined,

          organization: data.organization
            ? {
                connect: data.organization,
              }
            : undefined,

          password: data.password
            ? {
                connect: data.password,
              }
            : undefined,
        },
        select: {
          allowDynamicBooking: true,
          allowSEOIndexing: true,
          appTheme: true,
          avatar: true,
          avatarUrl: true,
          away: true,
          backupCodes: true,
          bio: true,
          brandColor: true,
          bufferTime: true,
          completedOnboarding: true,
          createdDate: true,
          darkBrandColor: true,
          defaultScheduleId: true,

          destinationCalendar: {
            select: {
              id: true,
            },
          },

          disableImpersonation: true,
          email: true,
          emailVerified: true,
          endTime: true,
          hideBranding: true,
          id: true,
          identityProvider: true,
          identityProviderId: true,
          invitedTo: true,
          locale: true,
          locked: true,
          metadata: true,

          movedToProfile: {
            select: {
              id: true,
            },
          },

          name: true,

          organization: {
            select: {
              id: true,
            },
          },

          password: {
            select: {
              id: true,
            },
          },

          receiveMonthlyDigestEmail: true,
          role: true,
          startTime: true,
          theme: true,
          timeFormat: true,
          timeZone: true,
          trialEndsAt: true,
          twoFactorEnabled: true,
          twoFactorSecret: true,
          username: true,
          verified: true,
          weekStart: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          `No resource was found for ${JSON.stringify(params)}`
        );
      }
      throw error;
    }
  }

  @common.Delete("/:id")
  @swagger.ApiOkResponse({ type: User })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  async deleteUser(
    @common.Param() params: UserWhereUniqueInput
  ): Promise<User | null> {
    try {
      return await this.service.deleteUser({
        where: params,
        select: {
          allowDynamicBooking: true,
          allowSEOIndexing: true,
          appTheme: true,
          avatar: true,
          avatarUrl: true,
          away: true,
          backupCodes: true,
          bio: true,
          brandColor: true,
          bufferTime: true,
          completedOnboarding: true,
          createdDate: true,
          darkBrandColor: true,
          defaultScheduleId: true,

          destinationCalendar: {
            select: {
              id: true,
            },
          },

          disableImpersonation: true,
          email: true,
          emailVerified: true,
          endTime: true,
          hideBranding: true,
          id: true,
          identityProvider: true,
          identityProviderId: true,
          invitedTo: true,
          locale: true,
          locked: true,
          metadata: true,

          movedToProfile: {
            select: {
              id: true,
            },
          },

          name: true,

          organization: {
            select: {
              id: true,
            },
          },

          password: {
            select: {
              id: true,
            },
          },

          receiveMonthlyDigestEmail: true,
          role: true,
          startTime: true,
          theme: true,
          timeFormat: true,
          timeZone: true,
          trialEndsAt: true,
          twoFactorEnabled: true,
          twoFactorSecret: true,
          username: true,
          verified: true,
          weekStart: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          `No resource was found for ${JSON.stringify(params)}`
        );
      }
      throw error;
    }
  }

  @common.Get("/:id/accessCodes")
  @ApiNestedQuery(AccessCodeFindManyArgs)
  async findAccessCodes(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<AccessCode[]> {
    const query = plainToClass(AccessCodeFindManyArgs, request.query);
    const results = await this.service.findAccessCodes(params.id, {
      ...query,
      select: {
        client: {
          select: {
            id: true,
          },
        },

        code: true,
        expiresAt: true,
        id: true,
        scopes: true,

        team: {
          select: {
            id: true,
          },
        },

        user: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/accessCodes")
  async connectAccessCodes(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: AccessCodeWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      accessCodes: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/accessCodes")
  async updateAccessCodes(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: AccessCodeWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      accessCodes: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/accessCodes")
  async disconnectAccessCodes(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: AccessCodeWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      accessCodes: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/accounts")
  @ApiNestedQuery(AccountFindManyArgs)
  async findAccounts(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<Account[]> {
    const query = plainToClass(AccountFindManyArgs, request.query);
    const results = await this.service.findAccounts(params.id, {
      ...query,
      select: {
        accessToken: true,
        expiresAt: true,
        id: true,
        idToken: true,
        provider: true,
        providerAccountId: true,
        refreshToken: true,
        scope: true,
        sessionState: true,
        tokenType: true,
        typeField: true,

        user: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/accounts")
  async connectAccounts(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: AccountWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      accounts: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/accounts")
  async updateAccounts(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: AccountWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      accounts: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/accounts")
  async disconnectAccounts(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: AccountWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      accounts: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/apiKeys")
  @ApiNestedQuery(ApiKeyFindManyArgs)
  async findApiKeys(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<ApiKey[]> {
    const query = plainToClass(ApiKeyFindManyArgs, request.query);
    const results = await this.service.findApiKeys(params.id, {
      ...query,
      select: {
        appField: {
          select: {
            id: true,
          },
        },

        createdAt: true,
        expiresAt: true,
        hashedKey: true,
        id: true,
        lastUsedAt: true,
        note: true,

        team: {
          select: {
            id: true,
          },
        },

        user: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/apiKeys")
  async connectApiKeys(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: ApiKeyWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      apiKeys: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/apiKeys")
  async updateApiKeys(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: ApiKeyWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      apiKeys: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/apiKeys")
  async disconnectApiKeys(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: ApiKeyWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      apiKeys: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/availability")
  @ApiNestedQuery(AvailabilityFindManyArgs)
  async findAvailability(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<Availability[]> {
    const query = plainToClass(AvailabilityFindManyArgs, request.query);
    const results = await this.service.findAvailability(params.id, {
      ...query,
      select: {
        date: true,
        days: true,
        endTime: true,

        eventType: {
          select: {
            id: true,
          },
        },

        id: true,

        schedule: {
          select: {
            id: true,
          },
        },

        startTime: true,

        user: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/availability")
  async connectAvailability(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: AvailabilityWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      availability: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/availability")
  async updateAvailability(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: AvailabilityWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      availability: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/availability")
  async disconnectAvailability(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: AvailabilityWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      availability: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/bookingRedirects")
  @ApiNestedQuery(OutOfOfficeEntryFindManyArgs)
  async findBookingRedirects(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<OutOfOfficeEntry[]> {
    const query = plainToClass(OutOfOfficeEntryFindManyArgs, request.query);
    const results = await this.service.findBookingRedirects(params.id, {
      ...query,
      select: {
        createdAt: true,
        end: true,
        id: true,
        start: true,

        toUser: {
          select: {
            id: true,
          },
        },

        updatedAt: true,

        user: {
          select: {
            id: true,
          },
        },

        uuid: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/bookingRedirects")
  async connectBookingRedirects(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: OutOfOfficeEntryWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      bookingRedirects: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/bookingRedirects")
  async updateBookingRedirects(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: OutOfOfficeEntryWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      bookingRedirects: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/bookingRedirects")
  async disconnectBookingRedirects(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: OutOfOfficeEntryWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      bookingRedirects: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/bookingRedirectsTo")
  @ApiNestedQuery(OutOfOfficeEntryFindManyArgs)
  async findBookingRedirectsTo(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<OutOfOfficeEntry[]> {
    const query = plainToClass(OutOfOfficeEntryFindManyArgs, request.query);
    const results = await this.service.findBookingRedirectsTo(params.id, {
      ...query,
      select: {
        createdAt: true,
        end: true,
        id: true,
        start: true,

        toUser: {
          select: {
            id: true,
          },
        },

        updatedAt: true,

        user: {
          select: {
            id: true,
          },
        },

        uuid: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/bookingRedirectsTo")
  async connectBookingRedirectsTo(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: OutOfOfficeEntryWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      bookingRedirectsTo: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/bookingRedirectsTo")
  async updateBookingRedirectsTo(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: OutOfOfficeEntryWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      bookingRedirectsTo: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/bookingRedirectsTo")
  async disconnectBookingRedirectsTo(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: OutOfOfficeEntryWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      bookingRedirectsTo: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/bookings")
  @ApiNestedQuery(BookingFindManyArgs)
  async findBookings(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<Booking[]> {
    const query = plainToClass(BookingFindManyArgs, request.query);
    const results = await this.service.findBookings(params.id, {
      ...query,
      select: {
        cancellationReason: true,
        createdAt: true,
        customInputs: true,
        description: true,

        destinationCalendar: {
          select: {
            id: true,
          },
        },

        dynamicEventSlugRef: true,
        dynamicGroupSlugRef: true,
        endTime: true,

        eventType: {
          select: {
            id: true,
          },
        },

        fromReschedule: true,
        iCalSequence: true,
        iCalUID: true,
        id: true,

        instantMeetingToken: {
          select: {
            id: true,
          },
        },

        isRecorded: true,
        location: true,
        metadata: true,
        paid: true,
        recurringEventId: true,
        rejectionReason: true,
        rescheduled: true,
        responses: true,
        scheduledJobs: true,
        smsReminderNumber: true,
        startTime: true,
        status: true,
        title: true,
        uid: true,
        updatedAt: true,

        user: {
          select: {
            id: true,
          },
        },

        userPrimaryEmail: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/bookings")
  async connectBookings(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: BookingWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      bookings: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/bookings")
  async updateBookings(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: BookingWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      bookings: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/bookings")
  async disconnectBookings(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: BookingWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      bookings: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/credentials")
  @ApiNestedQuery(CredentialFindManyArgs)
  async findCredentials(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<Credential[]> {
    const query = plainToClass(CredentialFindManyArgs, request.query);
    const results = await this.service.findCredentials(params.id, {
      ...query,
      select: {
        appField: {
          select: {
            id: true,
          },
        },

        billingCycleStart: true,
        id: true,
        invalid: true,
        key: true,
        paymentStatus: true,
        subscriptionId: true,

        team: {
          select: {
            id: true,
          },
        },

        typeField: true,

        user: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/credentials")
  async connectCredentials(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: CredentialWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      credentials: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/credentials")
  async updateCredentials(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: CredentialWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      credentials: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/credentials")
  async disconnectCredentials(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: CredentialWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      credentials: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/feedback")
  @ApiNestedQuery(FeedbackFindManyArgs)
  async findFeedback(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<Feedback[]> {
    const query = plainToClass(FeedbackFindManyArgs, request.query);
    const results = await this.service.findFeedback(params.id, {
      ...query,
      select: {
        comment: true,
        date: true,
        id: true,
        rating: true,

        user: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/feedback")
  async connectFeedback(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: FeedbackWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      feedback: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/feedback")
  async updateFeedback(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: FeedbackWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      feedback: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/feedback")
  async disconnectFeedback(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: FeedbackWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      feedback: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/hosts")
  @ApiNestedQuery(HostFindManyArgs)
  async findHosts(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<Host[]> {
    const query = plainToClass(HostFindManyArgs, request.query);
    const results = await this.service.findHosts(params.id, {
      ...query,
      select: {
        eventType: {
          select: {
            id: true,
          },
        },

        id: true,
        isFixed: true,
        priority: true,

        user: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/hosts")
  async connectHosts(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: HostWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      hosts: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/hosts")
  async updateHosts(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: HostWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      hosts: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/hosts")
  async disconnectHosts(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: HostWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      hosts: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/impersonatedBy")
  @ApiNestedQuery(ImpersonationFindManyArgs)
  async findImpersonatedBy(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<Impersonation[]> {
    const query = plainToClass(ImpersonationFindManyArgs, request.query);
    const results = await this.service.findImpersonatedBy(params.id, {
      ...query,
      select: {
        createdAt: true,
        id: true,

        impersonatedBy: {
          select: {
            id: true,
          },
        },

        impersonatedUser: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/impersonatedBy")
  async connectImpersonatedBy(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: ImpersonationWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      impersonatedBy: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/impersonatedBy")
  async updateImpersonatedBy(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: ImpersonationWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      impersonatedBy: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/impersonatedBy")
  async disconnectImpersonatedBy(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: ImpersonationWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      impersonatedBy: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/impersonatedUsers")
  @ApiNestedQuery(ImpersonationFindManyArgs)
  async findImpersonatedUsers(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<Impersonation[]> {
    const query = plainToClass(ImpersonationFindManyArgs, request.query);
    const results = await this.service.findImpersonatedUsers(params.id, {
      ...query,
      select: {
        createdAt: true,
        id: true,

        impersonatedBy: {
          select: {
            id: true,
          },
        },

        impersonatedUser: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/impersonatedUsers")
  async connectImpersonatedUsers(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: ImpersonationWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      impersonatedUsers: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/impersonatedUsers")
  async updateImpersonatedUsers(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: ImpersonationWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      impersonatedUsers: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/impersonatedUsers")
  async disconnectImpersonatedUsers(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: ImpersonationWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      impersonatedUsers: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/ownedEventTypes")
  @ApiNestedQuery(EventTypeFindManyArgs)
  async findOwnedEventTypes(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<EventType[]> {
    const query = plainToClass(EventTypeFindManyArgs, request.query);
    const results = await this.service.findOwnedEventTypes(params.id, {
      ...query,
      select: {
        afterEventBuffer: true,
        assignAllTeamMembers: true,
        beforeEventBuffer: true,
        bookingFields: true,
        bookingLimits: true,
        currency: true,
        description: true,

        destinationCalendar: {
          select: {
            id: true,
          },
        },

        disableGuests: true,
        durationLimits: true,
        eventName: true,

        hashedLink: {
          select: {
            id: true,
          },
        },

        hidden: true,
        hideCalendarNotes: true,
        id: true,
        isInstantEvent: true,
        length: true,
        locations: true,
        lockTimeZoneToggleOnBookingPage: true,
        metadata: true,
        minimumBookingNotice: true,
        offsetStart: true,
        onlyShowFirstAvailableSlot: true,

        owner: {
          select: {
            id: true,
          },
        },

        parent: {
          select: {
            id: true,
          },
        },

        periodCountCalendarDays: true,
        periodDays: true,
        periodEndDate: true,
        periodStartDate: true,
        periodType: true,
        position: true,
        price: true,

        profile: {
          select: {
            id: true,
          },
        },

        recurringEvent: true,
        requiresBookerEmailVerification: true,
        requiresConfirmation: true,

        schedule: {
          select: {
            id: true,
          },
        },

        schedulingType: true,
        seatsPerTimeSlot: true,
        seatsShowAttendees: true,
        seatsShowAvailabilityCount: true,
        slotInterval: true,
        slug: true,
        successRedirectUrl: true,

        team: {
          select: {
            id: true,
          },
        },

        timeZone: true,
        title: true,
        useEventTypeDestinationCalendarEmail: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/ownedEventTypes")
  async connectOwnedEventTypes(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: EventTypeWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      ownedEventTypes: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/ownedEventTypes")
  async updateOwnedEventTypes(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: EventTypeWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      ownedEventTypes: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/ownedEventTypes")
  async disconnectOwnedEventTypes(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: EventTypeWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      ownedEventTypes: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/profiles")
  @ApiNestedQuery(ProfileFindManyArgs)
  async findProfiles(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<Profile[]> {
    const query = plainToClass(ProfileFindManyArgs, request.query);
    const results = await this.service.findProfiles(params.id, {
      ...query,
      select: {
        createdAt: true,
        id: true,

        movedFromUser: {
          select: {
            id: true,
          },
        },

        organization: {
          select: {
            id: true,
          },
        },

        uid: true,
        updatedAt: true,

        user: {
          select: {
            id: true,
          },
        },

        username: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/profiles")
  async connectProfiles(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: ProfileWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      profiles: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/profiles")
  async updateProfiles(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: ProfileWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      profiles: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/profiles")
  async disconnectProfiles(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: ProfileWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      profiles: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/routingForms")
  @ApiNestedQuery(AppRoutingFormsFormFindManyArgs)
  async findRoutingForms(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<AppRoutingFormsForm[]> {
    const query = plainToClass(AppRoutingFormsFormFindManyArgs, request.query);
    const results = await this.service.findRoutingForms(params.id, {
      ...query,
      select: {
        createdAt: true,
        description: true,
        disabled: true,
        fields: true,
        id: true,
        name: true,
        position: true,
        routes: true,
        settings: true,

        team: {
          select: {
            id: true,
          },
        },

        updatedAt: true,

        user: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/routingForms")
  async connectRoutingForms(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: AppRoutingFormsFormWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      routingForms: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/routingForms")
  async updateRoutingForms(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: AppRoutingFormsFormWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      routingForms: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/routingForms")
  async disconnectRoutingForms(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: AppRoutingFormsFormWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      routingForms: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/schedules")
  @ApiNestedQuery(ScheduleFindManyArgs)
  async findSchedules(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<Schedule[]> {
    const query = plainToClass(ScheduleFindManyArgs, request.query);
    const results = await this.service.findSchedules(params.id, {
      ...query,
      select: {
        id: true,
        name: true,
        timeZone: true,

        user: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/schedules")
  async connectSchedules(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: ScheduleWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      schedules: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/schedules")
  async updateSchedules(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: ScheduleWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      schedules: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/schedules")
  async disconnectSchedules(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: ScheduleWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      schedules: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/selectedCalendars")
  @ApiNestedQuery(SelectedCalendarFindManyArgs)
  async findSelectedCalendars(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<SelectedCalendar[]> {
    const query = plainToClass(SelectedCalendarFindManyArgs, request.query);
    const results = await this.service.findSelectedCalendars(params.id, {
      ...query,
      select: {
        credential: {
          select: {
            id: true,
          },
        },

        externalId: true,
        id: true,
        integration: true,

        user: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/selectedCalendars")
  async connectSelectedCalendars(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: SelectedCalendarWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      selectedCalendars: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/selectedCalendars")
  async updateSelectedCalendars(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: SelectedCalendarWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      selectedCalendars: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/selectedCalendars")
  async disconnectSelectedCalendars(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: SelectedCalendarWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      selectedCalendars: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/sessions")
  @ApiNestedQuery(SessionFindManyArgs)
  async findSessions(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<Session[]> {
    const query = plainToClass(SessionFindManyArgs, request.query);
    const results = await this.service.findSessions(params.id, {
      ...query,
      select: {
        expires: true,
        id: true,
        sessionToken: true,

        user: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/sessions")
  async connectSessions(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: SessionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      sessions: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/sessions")
  async updateSessions(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: SessionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      sessions: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/sessions")
  async disconnectSessions(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: SessionWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      sessions: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/teams")
  @ApiNestedQuery(MembershipFindManyArgs)
  async findTeams(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<Membership[]> {
    const query = plainToClass(MembershipFindManyArgs, request.query);
    const results = await this.service.findTeams(params.id, {
      ...query,
      select: {
        accepted: true,
        disableImpersonation: true,
        id: true,
        role: true,

        team: {
          select: {
            id: true,
          },
        },

        user: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/teams")
  async connectTeams(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: MembershipWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      teams: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/teams")
  async updateTeams(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: MembershipWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      teams: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/teams")
  async disconnectTeams(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: MembershipWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      teams: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/verifiedNumbers")
  @ApiNestedQuery(VerifiedNumberFindManyArgs)
  async findVerifiedNumbers(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<VerifiedNumber[]> {
    const query = plainToClass(VerifiedNumberFindManyArgs, request.query);
    const results = await this.service.findVerifiedNumbers(params.id, {
      ...query,
      select: {
        id: true,
        phoneNumber: true,

        team: {
          select: {
            id: true,
          },
        },

        user: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/verifiedNumbers")
  async connectVerifiedNumbers(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: VerifiedNumberWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      verifiedNumbers: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/verifiedNumbers")
  async updateVerifiedNumbers(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: VerifiedNumberWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      verifiedNumbers: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/verifiedNumbers")
  async disconnectVerifiedNumbers(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: VerifiedNumberWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      verifiedNumbers: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/webhooks")
  @ApiNestedQuery(WebhookFindManyArgs)
  async findWebhooks(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<Webhook[]> {
    const query = plainToClass(WebhookFindManyArgs, request.query);
    const results = await this.service.findWebhooks(params.id, {
      ...query,
      select: {
        active: true,

        appField: {
          select: {
            id: true,
          },
        },

        createdAt: true,
        eventTriggers: true,

        eventType: {
          select: {
            id: true,
          },
        },

        id: true,
        payloadTemplate: true,
        secret: true,
        subscriberUrl: true,

        team: {
          select: {
            id: true,
          },
        },

        user: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/webhooks")
  async connectWebhooks(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: WebhookWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      webhooks: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/webhooks")
  async updateWebhooks(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: WebhookWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      webhooks: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/webhooks")
  async disconnectWebhooks(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: WebhookWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      webhooks: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Get("/:id/workflows")
  @ApiNestedQuery(WorkflowFindManyArgs)
  async findWorkflows(
    @common.Req() request: Request,
    @common.Param() params: UserWhereUniqueInput
  ): Promise<Workflow[]> {
    const query = plainToClass(WorkflowFindManyArgs, request.query);
    const results = await this.service.findWorkflows(params.id, {
      ...query,
      select: {
        id: true,
        name: true,
        position: true,

        team: {
          select: {
            id: true,
          },
        },

        time: true,
        timeUnit: true,
        trigger: true,

        user: {
          select: {
            id: true,
          },
        },
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/workflows")
  async connectWorkflows(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: WorkflowWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      workflows: {
        connect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/workflows")
  async updateWorkflows(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: WorkflowWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      workflows: {
        set: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/workflows")
  async disconnectWorkflows(
    @common.Param() params: UserWhereUniqueInput,
    @common.Body() body: WorkflowWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      workflows: {
        disconnect: body,
      },
    };
    await this.service.updateUser({
      where: params,
      data,
      select: { id: true },
    });
  }
}
